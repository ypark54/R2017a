/*
 * @(#)ne_mli_pub.h    generated by: makeheader 5.1.5  Thu Jan 19 13:09:46 2017
 *
 *		built from:	../../../../../src/include/copyright.h
 *				../../../../../src/include/pragma_interface.h
 *				include/nem_publish.h
 *				include/nem_exports.h
 *				../mw/basictypes.h
 *				../mw/equationdomain.h
 *				nem_builtins/nem_builtins_reg.cpp
 *				nem_cg/nem_cgparamsudc.cpp
 *				nem_construction/nem_assemblyconnectmi.cpp
 *				nem_construction/nem_assemblyitemclientdata.cpp
 *				nem_construction/nem_assemblyitempi.cpp
 *				nem_construction/nem_assemblyitemudc.cpp
 *				nem_construction/nem_assemblymethods.cpp
 *				nem_construction/nem_connectionmethodrecord.cpp
 *				nem_construction/nem_getassemblyiteminterfacesmi.cpp
 *				nem_construction/nem_inputdataudc.cpp
 *				nem_construction/nem_libraryelementequationbuilderudc.cpp
 *				nem_construction/nem_outputdataudc.cpp
 *				nem_construction/nem_schemacompiledata.cpp
 *				nem_construction/nem_schemacompiledataudc.cpp
 *				nem_construction/nem_schemadata.cpp
 *				nem_construction/nem_schemadataclientdata.cpp
 *				nem_construction/nem_schemadataudc.cpp
 *				nem_foundation/nem_context.cpp
 *				nem_foundation/nem_libraryitemregistry.cpp
 *				nem_foundation/nem_mlobjectdescriptor.cpp
 *				nem_foundation/nem_mlreservedwordmanager.cpp
 *				nem_foundation/nem_mlruntimeenvironment.cpp
 *				nem_foundation/nem_objectdescriptorudc.cpp
 *				nem_foundation/nem_private.cpp
 *				nem_foundation/nem_udiregistry.cpp
 *				nem_mcos/nem_priorityci.cpp
 *				nem_repository/nem_addschemaitemmi.cpp
 *				nem_repository/nem_elementschemaclientdata.cpp
 *				nem_repository/nem_equationmanager.cpp
 *				nem_repository/nem_getschemaitemsmi.cpp
 *				nem_repository/nem_hiddenpi.cpp
 *				nem_repository/nem_libraryelementsetupmi.cpp
 *				nem_repository/nem_libraryitemclientdata.cpp
 *				nem_repository/nem_libraryiteminfo.cpp
 *				nem_repository/nem_libraryiteminfoudc.cpp
 *				nem_repository/nem_libraryitemudc.cpp
 *				nem_repository/nem_mllibraryelementsetupinfo.cpp
 *				nem_repository/nem_schemaitemcilentdata.cpp
 *				nem_repository/nem_schemaitempi.cpp
 *				nem_repository/nem_schemaitemudc.cpp
 *				nem_repository/nem_terminaldomainschemapi.cpp
 *				nem_solverinterface/nem_createnesysteminputsmi.cpp
 *				nem_solverinterface/nem_nativetyperegistry.cpp
 *				nem_solverinterface/nem_nedsioinfoudc.cpp
 *				nem_solverinterface/nem_nedynamicsysteminputudc.cpp
 *				nem_solverinterface/nem_nedynamicsystemmi.cpp
 *				nem_solverinterface/nem_nedynamicsystemudc.cpp
 *				nem_solverinterface/nem_neequationdatapi.cpp
 *				nem_solverinterface/nem_neioinfopi.cpp
 *				nem_solverinterface/nem_nestandardsolvemi.cpp
 *				nem_solverinterface/nem_nestandardsystemmi.cpp
 *				nem_solverinterface/nem_nesysteminputudc.cpp
 *				nem_solverinterface/nem_structpi.cpp
 *				nem_udd/nem_accesstypetype.cpp
 *				nem_udd/nem_application.cpp
 *				nem_udd/nem_assemblyitemtypetype.cpp
 *				nem_udd/nem_boolpi.cpp
 *				nem_udd/nem_checksumtype.cpp
 *				nem_udd/nem_class.cpp
 *				nem_udd/nem_conversiontypetype.cpp
 *				nem_udd/nem_displaymi.cpp
 *				nem_udd/nem_enumtypepi.cpp
 *				nem_udd/nem_generictypemi.cpp
 *				nem_udd/nem_generictypepi.cpp
 *				nem_udd/nem_iconrotationtype.cpp
 *				nem_udd/nem_initmodetype.cpp
 *				nem_udd/nem_libraryitemtypetype.cpp
 *				nem_udd/nem_neboolvectortype.cpp
 *				nem_udd/nem_necharvectortype.cpp
 *				nem_udd/nem_neintvectortype.cpp
 *				nem_udd/nem_nenumericvectortype.cpp
 *				nem_udd/nem_nerealvectortype.cpp
 *				nem_udd/nem_nesparsitypatterntype.cpp
 *				nem_udd/nem_nominalsourcetype.cpp
 *				nem_udd/nem_portlocatortype.cpp
 *				nem_udd/nem_propagationtypetype.cpp
 *				nem_udd/nem_schemaitemtypetype.cpp
 *				nem_udd/nem_sparsitypatternmanager.cpp
 *				nem_udd/nem_statespecificationhelper.cpp
 *				nem_udd/nem_statespecificationtype.cpp
 *				nem_udd/nem_statespecificationudc.cpp
 *				nem_udd/nem_statespecprioritytype.cpp
 *				nem_udd/nem_timestamptype.cpp
 *				nem_udd/nem_uddvectorinfo.cpp
 *				../mw/equationinfo.h
 *				../mw/customequationinfo_deploy.h
 *				../mw/math_deploy.h
 *				../mw/equationdata.h
 */

#if defined(_MSC_VER)
# pragma once
#endif
#if defined(__GNUC__) && (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ > 3))
# pragma once
#endif

#ifndef ne_mli_pub_h
#define ne_mli_pub_h


/*
 * Copyright 1984-2003 The MathWorks, Inc.
 * All Rights Reserved.
 */



/* Copyright 2003-2006 The MathWorks, Inc. */

/* Only define EXTERN_C if it hasn't been defined already. This allows
 * individual modules to have more control over managing their exports.
 */
#ifndef EXTERN_C

#ifdef __cplusplus
  #define EXTERN_C extern "C"
#else
  #define EXTERN_C extern
#endif

#endif


/*********************************************************************************************************************
 ** File: nem_publish.h
 ** Abstract:
 **     Published header for network engine matlab interface
 **
 ** Copyright 2004-2006 The MathWorks, Inc.
 *********************************************************************************************************************/


#ifndef __nem_publish_h__
#define __nem_publish_h__

#ifndef EXTERN_C

#ifdef __cplusplus
  #define EXTERN_C extern "C"
#else
  #define EXTERN_C extern
#endif

#endif

#include <tmwtypes.h>

#ifndef TRUE
#define TRUE                          (1U)
#endif

#ifndef FALSE
#define FALSE                         (0U)
#endif

#include <physmod/common/foundation/core/util.h>

#endif /* __nem_publish_h__ */
/* [EOF] nem_publish.h */


/*********************************************************************************************************************
 ** File: nem_exports.h
 ** Abstract:
 **
 ** Copyright 2004-2006 The MathWorks, Inc.
 *********************************************************************************************************************/


#ifndef __nem_exports_h__
#define __nem_exports_h__

#ifdef __cplusplus

// Only sensible way to make ne_mli.h standalone

#include <physmod/network_engine/basictypes.h>
#include <physmod/network_engine/dynamicsystem.h>
#include <physmod/network_engine/equationinfo.h>
#include <physmod/network_engine/diagnostic_tree_fwd.h>

namespace network_engine
{
    class Context;
    class LibraryElementBuilder;
    class EquationGroup;
    class EquationGroupInfo;
    class Equation;
    class VariableElement;
    template < typename _Type >
    class UddInfo;
}

typedef network_engine::LibraryElementBuilder  NeLibraryElementBuilder;
typedef network_engine::EquationGroup          NeEquationGroup;
typedef network_engine::Equation               NeEquation;
typedef network_engine::VariableElement        NeVariableElement;


#else


typedef struct NeLibraryElementBuilderTag      NeLibraryElementBuilder;
typedef struct NeEquationGroupTag              NeEquationGroup;
typedef struct NeEquationTag                   NeEquation;
typedef struct NeVariableEleemntTag            NeVariableElement;

#endif /* __cplusplus */

#endif /* __nem_exports_h__ */
/* [EOF] nem_exports.h */



/*******************************************************************************
 ** File: basictypes.h
 ** Abstract:
 **      Basic exported network_engine types
 ** 
 ** Copyright 2004-2015 The MathWorks, Inc.
 *******************************************************************************/

#ifndef __network_engine_basictypes_h__
#define __network_engine_basictypes_h__

#include <physmod/common/foundation/core/types.h>
#include <physmod/common/math/core/linearalgebra_fwd.h>
#include <physmod/network_engine/types.h>
#include <physmod/common/math/core/functions_fwd.h>

#endif /* include guard */


/******************************************************************************
 ** File: equationdomain.h
 ** Abstract:
 **     Define the equation domain enum.
 ** 
 ** Copyright 2012 The MathWorks, Inc.
 ******************************************************************************/

#ifndef __network_engine_equationdomain_h__
#define __network_engine_equationdomain_h__

#define NE_EQUATION_DOMAIN_MACRO(_X)            \
    _X( TIME      )                             \
    _X( FREQUENCY_REAL )                        \
    _X( FREQUENCY_IMAG )                        \
    _X( COMPLEX   )                             \
    _X( DELAY     )                             \

#define NE_EQUATION_DOMAIN_ENUM(_id) NE_EQUATION_DOMAIN_##_id,

typedef enum NeEquationDomainTag
{
    NE_EQUATION_DOMAIN_INVALID = -1,
    NE_EQUATION_DOMAIN_MACRO(NE_EQUATION_DOMAIN_ENUM)
    NE_EQUATION_DOMAIN_NUM
} NeEquationDomain;

#endif


/*********************************************************************************************************************
 ** File: equationinfo.h
 ** Abstract:
 **     Define the interface for a Network Engine Dynamic System.
 ** 
 ** Copyright 2004-2010 The MathWorks, Inc.
 *********************************************************************************************************************/


#ifndef __network_engine_equationinfo_h__
#define __network_engine_equationinfo_h__

#define NE_EQUATION_GROUP_INFO_METHOD_MACRO(_X)       \
    _X(ZC,          real_T   *)                       \
    _X(MODE,        int32_T  *)                       \
    _X(CACHE,       int32_T  *)                       \
    _X(UPDATE_R,    real_T   *)                       \
    _X(UPDATE_I,    int32_T  *)                       \
    _X(SFO,         real_T   *)                       \
    _X(SFP,         real_T   *)                       \
    _X(INIT_R,      real_T   *)                       \
    _X(INIT_I,      int32_T  *)                       \
    _X(ASSERT,      int32_T  *)                       \
    _X(DEL_T,       real_T   *)                       \
    _X(DEL_V,       real_T   *)                       \
    _X(DEL_V0,      real_T   *)                       \
    _X(DEL_TMAX,    real_T   *)                       \
    _X(DDELT,       real_T   *)                       \
    _X(DDELT_P,     int32_T  *)                       \

#define NE_EQUATION_INFO_PARAM_METHOD_MACRO(_X) \
    _X(C1,    real_T *)                         \
    
#define NE_EQUATION_INFO_METHOD_MACRO(_X)                               \
    _X(M,     real_T,      false)                                       \
    _X(DM_P,  int32_T *,   true)                                        \
    _X(DM,    real_T *,    false)                                       \
    _X(F,     real_T,      false)                                       \
    _X(VMF,   boolean_T,   false)                                       \
    _X(SLF,   boolean_T,   false)                                       \
    _X(VMM,   boolean_T,   false)                                       \
    _X(DF_P,  int32_T *,   true)                                        \
    _X(DF,    real_T *,    false)                                       \
    _X(DDF_P, int32_T *,   true)                                        \
    _X(DDF,   real_T *,    false)                                       \
    _X(TDF_P, int32_T *,   true)                                        \
    
#define NE_EQUATION_GROUP_INFO_METHOD_ID(_id) NE_EQ_GROUP_##_id
#define NE_EQUATION_INFO_PARAM_METHOD_ID(_id) NE_EQ_PARAM_##_id
#define NE_EQUATION_INFO_METHOD_ID(      _id) NE_EQ_##_id

#define NE_EQUATION_GROUP_INFO_METHOD_ENUM(_id, _type) NE_EQUATION_GROUP_INFO_METHOD_ID(_id),
#define NE_EQUATION_INFO_PARAM_METHOD_ENUM(_id, _type) NE_EQUATION_INFO_PARAM_METHOD_ID(_id),
#define NE_EQUATION_INFO_METHOD_ENUM(      _id, _type, _const) NE_EQUATION_INFO_METHOD_ID(_id),

typedef enum NeEqGroupMethodIdTag
{
    NE_EQ_GROUP_INVALID = -1,
    NE_EQUATION_GROUP_INFO_METHOD_MACRO(NE_EQUATION_GROUP_INFO_METHOD_ENUM)
    NE_EQ_GROUP_NUM
} NeEqGroupMethodId;

typedef enum NeEqParamMethodIdTag
{
    NE_EQ_PARAM_INVALID = -1,
    NE_EQUATION_INFO_PARAM_METHOD_MACRO(NE_EQUATION_INFO_PARAM_METHOD_ENUM)
    NE_EQ_PARAM_NUM
} NeEqParamMethodId;

typedef enum NeEqMethodIdTag
{
    NE_EQ_INVALID = -1,
    NE_EQUATION_INFO_METHOD_MACRO(NE_EQUATION_INFO_METHOD_ENUM)
    NE_EQ_NUM
} NeEqMethodId;

#define NE_EQUATION_INFO_OUTPUT_FIELD(_id, _type) _type m##_id;

#define NE_EQUATION_METHOD_INFO_OUTPUT_FIELD(_id, _type, _const) _type m##_id;

typedef union NeEqGroupMethodOutputTag
{
    NE_EQUATION_GROUP_INFO_METHOD_MACRO(NE_EQUATION_INFO_OUTPUT_FIELD)
} NeEqGroupMethodOutput;

typedef union NeEqMethodParamOutputTag
{
    NE_EQUATION_INFO_PARAM_METHOD_MACRO(NE_EQUATION_INFO_OUTPUT_FIELD)
} NeEqParamMethodOutput;

typedef union NeEqMethodOutputTag
{
    NE_EQUATION_INFO_METHOD_MACRO(NE_EQUATION_METHOD_INFO_OUTPUT_FIELD)
} NeEqMethodOutput;

typedef struct NeEqMethodInputTag NeEqMethodInput;

#ifdef __cplusplus
namespace network_engine
{
    class ElementEquationGroupInfo;
}
typedef network_engine::ElementEquationGroupInfo NeElementEquationGroupInfo;
#else
typedef struct NeElementEquationGroupInfoTag NeElementEquationGroupInfo;
#endif

typedef void *(*NeEqSetupFcn)     (const NeElementEquationGroupInfo *);
typedef void  (*NeEqCleanupFcn)   (void *);
typedef void  (*NeEqParamMethod)  (const void *, NeEqParamMethodOutput *);
typedef void  (*NeEqMethod)       (const NeEqMethodInput *, NeEqMethodOutput *);

#define NE_EQ_METHOD_INPUT_MACRO( _X )                  \
    _X( X,  real_T         ) /* input (variables) */    \
    _X( M,  int32_T        ) /* mode              */    \
    _X( Q,  int32_T        ) /* major mode        */    \
    _X( W,  real_T         ) /* delay values      */    \

#define NE_EQ_METHOD_INPUT_DEFN( _id, _type ) _type *m##_id;

struct NeEqMethodInputTag
{
    NE_EQ_METHOD_INPUT_MACRO( NE_EQ_METHOD_INPUT_DEFN )
    /*!
     * equation subclass data
     */
    void              *mEqData;
};

#endif /* include guard */




/*********************************************************************************************************************
 ** File: customequationinfo_deploy.h
 ** Abstract:
 **     Define custom equation info 
 ** 
 ** Copyright 2011-2012 The MathWorks, Inc.
 *********************************************************************************************************************/


#ifndef __network_engine_customequationinfo_deploy_h__
#define __network_engine_customequationinfo_deploy_h__

/* 

   avoid warning of undefined functions while keeping ne_mli_pub.h stand alone.

*/

typedef struct FunDataTag FunData;

#define ne_eq_input_get_fundata(_idx) ((FunData *) (( (EqData *) ((input)->mEqData) )->mFunData[_idx])) 
#define ne_eq_get_fundata_in_eqdata(_ed, _idx) (&(_ed)->mFunData[_idx]) 
#define ne_eq_set_element(_a, _idx, _c) ((_a)[_idx] = (_c))

EXTERN_C void tlu1_eq_setup(size_t n, const void **data, const size_t *sizes, FunData ** dataOutp );
EXTERN_C void tlu1_eq_cleanup( FunData *data );
EXTERN_C void tlu1_eq_F(  const real_T * input, const int32_T * mode, const int32_T * major, FunData * data, real_T *f);
EXTERN_C void tlu1_eq_DF_0_1(  const real_T * input, const int32_T * mode, const int32_T * major, FunData * data, real_T *df);
EXTERN_C void tlu1_eq_MODE_0(  const real_T * input, const int32_T * mode, const int32_T * major, FunData * data, int32_T *modeOut); 
EXTERN_C void tlu1_eq_MODE_1(  const real_T * input, const int32_T * mode, const int32_T * major, FunData * data, int32_T *modeOut); 
EXTERN_C void tlu1_eq_ZC_0(  const real_T * input, const int32_T * mode, const int32_T * major, FunData * data, real_T *out); 
EXTERN_C void tlu1_eq_ZC_1(  const real_T * input, const int32_T * mode, const int32_T * major, FunData * data, real_T *out); 

EXTERN_C void tlu2_eq_setup(size_t n, const void **data, const size_t *sizes, FunData ** dataOutp );
EXTERN_C void tlu2_eq_cleanup( FunData *data );
EXTERN_C void tlu2_eq_F( const real_T * input, const int32_T * mode, const int32_T * major, FunData * data, real_T *f);
EXTERN_C void tlu2_eq_DF_0_1( const real_T * input, const int32_T * mode, const int32_T * major, FunData * data, real_T *df);
EXTERN_C void tlu2_eq_DF_1_1( const real_T * input, const int32_T * mode, const int32_T * major, FunData * data, real_T *df);
EXTERN_C void tlu2_eq_MODE_0( const real_T * input, const int32_T * mode, const int32_T * major, FunData * data, int32_T *modeOut); 
EXTERN_C void tlu2_eq_MODE_1( const real_T * input, const int32_T * mode, const int32_T * major, FunData * data, int32_T *modeOut); 
EXTERN_C void tlu2_eq_MODE_2( const real_T * input, const int32_T * mode, const int32_T * major, FunData * data, int32_T *modeOut); 
EXTERN_C void tlu2_eq_MODE_3( const real_T * input, const int32_T * mode, const int32_T * major, FunData * data, int32_T *modeOut); 
EXTERN_C void tlu2_eq_ZC_0( const real_T * input, const int32_T * mode, const int32_T * major, FunData * data, real_T *out); 
EXTERN_C void tlu2_eq_ZC_1( const real_T * input, const int32_T * mode, const int32_T * major, FunData * data, real_T *out); 
EXTERN_C void tlu2_eq_ZC_2( const real_T * input, const int32_T * mode, const int32_T * major, FunData * data, real_T *out); 
EXTERN_C void tlu2_eq_ZC_3( const real_T * input, const int32_T * mode, const int32_T * major, FunData * data, real_T *out); 

EXTERN_C void floor_eq_setup(size_t n, const void **data, const size_t *sizes, FunData **dataOutp);
EXTERN_C void floor_eq_cleanup(FunData *data);
EXTERN_C void floor_eq_F( const real_T * input, const int32_T * mode, const int32_T * major, FunData * data, real_T *f);
EXTERN_C void floor_eq_DF_0_1( const real_T * input, const int32_T * mode, const int32_T * major, FunData * data, real_T * df);
EXTERN_C void floor_eq_MODE_0( const real_T * input, const int32_T * mode, const int32_T * major, FunData * data,  int32_T *modeOut ); 
EXTERN_C void floor_eq_MODE_1( const real_T * input, const int32_T * mode, const int32_T * major, FunData * data, int32_T *modeOut );
EXTERN_C void floor_eq_ZC_0(const real_T * input, const int32_T * mode, const int32_T * major, FunData * data, real_T *zc); 
EXTERN_C void floor_eq_ZC_1(const real_T * input, const int32_T * mode, const int32_T * major, FunData * data, real_T *zc);

EXTERN_C void ceil_eq_setup(size_t n, const void **data, const size_t *sizes, FunData **dataOutp);
EXTERN_C void ceil_eq_cleanup(FunData *data);
EXTERN_C void ceil_eq_F( const real_T * input, const int32_T * mode, const int32_T * major, FunData * data, real_T *f);
EXTERN_C void ceil_eq_DF_0_1( const real_T * input, const int32_T * mode, const int32_T * major, FunData * data, real_T * df);
EXTERN_C void ceil_eq_MODE_0( const real_T * input, const int32_T * mode, const int32_T * major, FunData * data,  int32_T *modeOut );
EXTERN_C void ceil_eq_MODE_1( const real_T * input, const int32_T * mode, const int32_T * major, FunData * data, int32_T *modeOut );
EXTERN_C void ceil_eq_ZC_0(const real_T * input, const int32_T * mode, const int32_T * major, FunData * data, real_T *zc); 
EXTERN_C void ceil_eq_ZC_1(const real_T * input, const int32_T * mode, const int32_T * major, FunData * data, real_T *zc);

EXTERN_C void fix_eq_setup(size_t n, const void **data, const size_t *sizes, FunData **dataOutp);
EXTERN_C void fix_eq_cleanup(FunData *data);
EXTERN_C void fix_eq_F( const real_T * input, const int32_T * mode, const int32_T * major, FunData * data, real_T *f);
EXTERN_C void fix_eq_DF_0_1( const real_T * input, const int32_T * mode, const int32_T * major, FunData * data, real_T * df);
EXTERN_C void fix_eq_MODE_0( const real_T * input, const int32_T * mode, const int32_T * major, FunData * data,  int32_T *modeOut ); 
EXTERN_C void fix_eq_MODE_1( const real_T * input, const int32_T * mode, const int32_T * major, FunData * data, int32_T *modeOut );
EXTERN_C void fix_eq_ZC_0(const real_T * input, const int32_T * mode, const int32_T * major, FunData * data, real_T *zc); 
EXTERN_C void fix_eq_ZC_1(const real_T * input, const int32_T * mode, const int32_T * major, FunData * data, real_T *zc);

EXTERN_C void round_eq_setup(size_t n, const void **data, const size_t *sizes, FunData **dataOutp);
EXTERN_C void round_eq_cleanup(FunData *data);
EXTERN_C void round_eq_F( const real_T * input, const int32_T * mode, const int32_T * major, FunData * data, real_T *f);
EXTERN_C void round_eq_DF_0_1( const real_T * input, const int32_T * mode, const int32_T * major, FunData * data, real_T * df);
EXTERN_C void round_eq_MODE_0( const real_T * input, const int32_T * mode, const int32_T * major, FunData * data,  int32_T *modeOut ); 
EXTERN_C void round_eq_MODE_1( const real_T * input, const int32_T * mode, const int32_T * major, FunData * data, int32_T *modeOut );
EXTERN_C void round_eq_ZC_0(const real_T * input, const int32_T * mode, const int32_T * major, FunData * data, real_T *zc); 
EXTERN_C void round_eq_ZC_1(const real_T * input, const int32_T * mode, const int32_T * major, FunData * data, real_T *zc);

#endif /* include guard */


/* LocalWords:  mli
 */


/*********************************************************************************************************************
 ** File: math_deploy.h
 ** Abstract:
 **     Provide header for math functions
 ** 
 ** Copyright 2012 The MathWorks, Inc.
 *********************************************************************************************************************/


#ifndef __network_engine_math_deploy_h__
#define __network_engine_math_deploy_h__

#include <math.h>

#endif /* include guard */


/* LocalWords:  mli
 */


/*******************************************************************************
 ** File: equationdata.h
 ** Abstract:
 **     Define function variable and equation data
 **
 ** Copyright 2007-2016 The MathWorks, Inc.
 *******************************************************************************/

#ifndef __network_engine_equationdata_h__
#define __network_engine_equationdata_h__

#ifndef ne_mli_pub_h
#include <physmod/network_engine/equationdomain.h>
#endif

typedef unsigned int NeDsEquationFlag;
typedef unsigned int NeDsVariableFlag;

/*

  Field descriptions by field name
  ================================

  mFullPath     : full path of the artifact (may be NULL)
  mObject       : instance descriptor (may be NULL)
  mDescription  : human-friendly description

  mM            : number of rows in containing artifact
  mN            : number of columns in containing artifact
  mIndex        : 0-based index, column-major order

  mNumRanges    : number of locations
  mStart        : the index of the first location

  mUnit         : computational unit
  mIcValue      : initial condition in computational unit

  mIsDetermined : Is the value determined by parameters/time/inputs/?

  mFileName     : file name
  mBeginLine    : line number
  mBeginColumn  : column number
  mEndLine      : line number
  mEndColumn    : column number

  mIsWarn       : warn or error
  mMessage      : warning or error message
  mMessageID    : message ID, could be empty

*/

#define NE_DATA_DECL(_name, _type) _type m##_name;

/*!
 * Equation data
 */

#define NE_EQN_DATA_FIELDS( _X )                \
    _X( FullPath,          const char *     )   \
    _X( Index,             size_t           )   \
    _X( Flags,             NeDsEquationFlag )   \
    _X( Domain,            NeEquationDomain )   \
    _X( Object,            const char *     )   \
    _X( NumRanges,         size_t           )   \
    _X( Start,             size_t           )   \
    _X( IsSwitchedLinear,  boolean_T        )   \
    _X( Scale,             real_T           )   \
    _X( Unit,              const char *     )   \

typedef struct NeDsEquationDataTag
{
    NE_EQN_DATA_FIELDS(NE_DATA_DECL)
} NeEquationData;

/*!
 * Variable data
 */

#define NE_VAR_DATA_FIELDS( _X )                \
    _X( FullPath,          const char *     )   \
    _X( Index,             size_t           )   \
    _X( Flags,             NeDsVariableFlag )   \
    _X( Object,            const char *     )   \
    _X( Scale,             real_T           )   \
    _X( Unit,              const char *     )   \
    _X( ICValue,           real_T           )   \
    _X( IsDifferential,    boolean_T        )   \
    _X( M,                 size_t           )   \
    _X( N,                 size_t           )   \
    _X( InitMode,          NeInitMode       )   \
    _X( Description,       const char *     )   \

typedef struct NeVariableDataTag
{
    NE_VAR_DATA_FIELDS(NE_DATA_DECL)
} NeVariableData;

/*!
 * Observable data
 */

#define NE_OBS_DATA_FIELDS( _X )                \
    _X( FullPath,          const char *    )    \
    _X( Object,            const char *    )    \
    _X( M,                 size_t          )    \
    _X( N,                 size_t          )    \
    _X( Unit,              const char *    )    \
    _X( NominalValue,      real_T          )    \
    _X( NominalUnit,       const char *    )    \
    _X( NominalSource,     NeNominalSource )    \
    _X( InitMode,          NeInitMode      )    \
    _X( IsDetermined,      boolean_T       )    \
    _X( IsDifferential,    boolean_T       )    \
    _X( Description,       const char *    )    \

typedef struct NeObservableDataTag
{
    NE_OBS_DATA_FIELDS(NE_DATA_DECL)
} NeObservableData;

/*!
 * Mode data
 */

#define NE_MODE_DATA_FIELDS( _X )               \
    _X( FullPath,  const char *         )       \
    _X( Index,     size_t               )       \
    _X( Object,    const char *         )       \
    _X( ICValue,   int32_T              )       \
    _X( Description,       const char *    )    \

typedef struct NeModeDataTag
{
    NE_MODE_DATA_FIELDS(NE_DATA_DECL)
} NeModeData;

/*!
 * Range data
 */

#define NE_RANGE_TYPE_MACRO(_X)                 \
    _X( NORMAL    )                             \
    _X( PROTECTED )                             \
    _X( NA        )                             \

#define NE_RANGE_TYPE_ENUM( _id ) NE_RANGE_TYPE_##_id
#define NE_RANGE_TYPE_DECL( _id ) NE_RANGE_TYPE_ENUM(_id),

typedef enum NeRangeTypeIdTag
{
    NE_RANGE_TYPE_INVALID = -1,
    NE_RANGE_TYPE_MACRO(NE_RANGE_TYPE_DECL)
    NE_RANGE_TYPE_NUM
} NeRangeTypeId;

#define NE_RANGE_FIELDS( _X )                   \
    _X( FileName,    const char *       )       \
    _X( BeginLine,   size_t             )       \
    _X( BeginColumn, size_t             )       \
    _X( EndLine,     size_t             )       \
    _X( EndColumn,   size_t             )       \
    _X( Type,        NeRangeTypeId      )       \

typedef struct NeRangeTag
{
    NE_RANGE_FIELDS(NE_DATA_DECL)
} NeRange;

/*!
 * Zc data
 */

#define NE_ZC_TYPE_MACRO(_X)                    \
    _X( _TRUE    )                              \
    _X( _FALSE   )                              \
    _X( _EITHER  )                              \

#define NE_ZC_TYPE_ENUM( _id ) NE_ZC_TYPE##_id
#define NE_ZC_TYPE_DECL( _id ) NE_ZC_TYPE_ENUM(_id),

typedef enum NeZcTypeTag
{
    NE_ZC_TYPE_INVALID = -1,
    NE_ZC_TYPE_MACRO(NE_ZC_TYPE_DECL)
    NE_ZC_TYPE_NUM
} NeZcType;

#define NE_ZC_DATA_FIELDS( _X )                 \
    _X( Object,     const char *        )       \
    _X( NumRanges,  size_t              )       \
    _X( Start,      size_t              )       \
    _X( Path,       const char *        )       \
    _X( Descriptor, const char *        )       \
    _X( Type,       NeZcType            )       \

typedef struct NeZCDataTag
{
    NE_ZC_DATA_FIELDS(NE_DATA_DECL)
} NeZCData;

/*!
 * Assert data
 */

#define NE_ASSERT_DATA_FIELDS( _X )             \
    _X( Object,     const char *        )       \
    _X( NumRanges,  size_t              )       \
    _X( Start,      size_t              )       \
    _X( Path,       const char *        )       \
    _X( Descriptor, const char *        )       \
    _X( IsWarn,     boolean_T           )       \
    _X( Message,    const char *        )       \
    _X( MessageID,  const char *        )       \

typedef struct NeAssertDataTag
{
    NE_ASSERT_DATA_FIELDS(NE_DATA_DECL)
} NeAssertData;

/*!
 * Parameter data
 */

#define NE_PARAM_DATA_FIELDS( _X )              \
    _X( FullPath,          const char *     )   \
    _X( Object,            const char *     )   \
    _X( Description,       const char *     )   \
    _X( Index,             size_t           )   \
    _X( M,                 size_t           )   \
    _X( N,                 size_t           )   \

typedef struct NeParameterDataTag
{
    NE_PARAM_DATA_FIELDS(NE_DATA_DECL)
} NeParameterData;

#ifdef __cplusplus

#include <string>

#define NE_DATA_MACRO(_X)                       \
    _X( NeEquationData   )                      \
    _X( NeVariableData   )                      \
    _X( NeObservableData )                      \
    _X( NeModeData       )                      \
    _X( NeRange          )                      \
    _X( NeZCData         )                      \
    _X( NeAssertData     )                      \
    _X( NeParameterData  )                      \

namespace network_engine
{
    /// Convenience name maps


    template <typename T>
        struct NeDataNameString {};

#define NE_DATA_NAME(_class)                                    \
    template <> struct NeDataNameString<_class>                 \
    {                                                           \
        static const std::string value()                        \
        {                                                       \
            return #_class;                                     \
        }                                                       \
    };
    NE_DATA_MACRO(NE_DATA_NAME);
#undef NE_DATA_NAME

}

#endif

#endif /* include guard */

#endif /* ne_mli_pub_h */
